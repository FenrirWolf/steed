#!/usr/bin/env python
# Usage:
# errno.py path/to/linux
from __future__ import print_function

import argparse
from collections import defaultdict, namedtuple, OrderedDict
import os.path
import re
import sys

DEFINE_REGEX=re.compile(r"^#define\s+(?P<name>E[A-Z0-9]+)\s+(?P<value>\w+)\s*(\/\* (?P<comment>.*) \*\/\s*)?$")

ErrnoValue = namedtuple('ErrnoValue', 'name value comment')

def parse_line(line):
    m = DEFINE_REGEX.match(line)
    if m:
        return ErrnoValue(**m.groupdict())

def parse_file(path):
    parsed = (parse_line(line) for line in open(path))
    return [p for p in parsed if p is not None]

def print_module(name, l):
    print()
    print("#[allow(dead_code)]")
    print("mod {} {{".format(name))
    print("    use libc::c_int;")
    print()
    for v in l:
        prefix = ""
        try:
            int(v.value)
        except ValueError:
            prefix = "super::"
        print("    pub const {name}: c_int = {prefix}{value};".format(prefix=prefix, **v._asdict()))
    print("}")

def main():
    parser = argparse.ArgumentParser(description="Generate Linux errno constants")
    parser.add_argument('linux_source', metavar="LINUX_SOURCE", help="Path to the Linux source code")
    parser.add_argument('arch_mapping', metavar="ARCH_MAPPING", nargs='*', help="Add an architecture mapping, `<linux>:<rust>`, e.g. `mips:mips,mips64`")
    args = parser.parse_args()

    arch_mapping = defaultdict(lambda: [])
    for a in args.arch_mapping:
        linux, rust = a.split(':', 1)
        rust = rust.split(',')
        arch_mapping[linux] += rust

    def parse_file_rel(path):
        return parse_file(os.path.join(args.linux_source, path))

    base = parse_file_rel("include/uapi/asm-generic/errno-base.h")
    generic = parse_file_rel("include/uapi/asm-generic/errno.h")
    arch = {a: parse_file_rel("arch/{}/include/uapi/asm/errno.h".format(a)) for a in arch_mapping}

    print("// NOTE: The following code was generated by \"generate/errno.py\",")
    print("//       do not edit directly!")
    print()
    print("// Generating command line:")
    print("// generate/errno.py path/to/linux/src {} > src/linux/errno.rs".format(" ".join(args.arch_mapping)))
    print()
    print("pub use self::base::*;")
    print()
    if arch:
        print("#[cfg(not(any({})))]".format(",\n              ".join(
            'target_arch = "{}"'.format(a) for a in sum(arch_mapping.values(), [])
        )))
    print("pub use self::generic::*;")
    for linux, rust in arch_mapping.items():
        print()
        print("#[cfg(any({}))]".format(",\n          ".join(
            'target_arch = "{}"'.format(a) for a in rust
        )))
        print("pub use self::{}::*;".format(linux))

    print_module("base", base)
    print_module("generic", generic)
    for a, errnos in arch.items():
        print_module(a, errnos)
    print()
    print("// Some errno values coincide on some platforms, while they don't on others.")
    print("#[allow(unreachable_patterns)]")
    print("pub fn error_string(errno: i32) -> Option<&'static str> {")
    print("    Some(match errno {")
    constants = OrderedDict((v.name, v) for v in base + generic)
    for v in constants.values():
        if v.comment is None:
            v = v._replace(comment=constants[v.value].comment)
        print("        {name} => \"{comment}\",".format(**v._asdict()))
    print("        _ => return None,")
    print("    })")
    print("}")


if __name__ == '__main__':
    main()
